diff --git a/node_modules/diff-match-patch/index.js b/node_modules/diff-match-patch/index.js
index 4d5542c..578710f 100644
--- a/node_modules/diff-match-patch/index.js
+++ b/node_modules/diff-match-patch/index.js
@@ -1,3 +1,9 @@
+/**
+ * Emoji fix obtained from: https://github.com/google/diff-match-patch/pull/13
+ * I removed the asserts throughout the code to minimize overhead of this solution
+ * sbatista@salesforce.com (08/23/22)
+ */
+
 /**
  * Diff Match and Patch
  * Copyright 2018 The diff-match-patch Authors.
@@ -26,7 +32,7 @@
  * Class containing the diff, match and patch methods.
  * @constructor
  */
-var diff_match_patch = function() {
+ function diff_match_patch() {
 
   // Defaults.
   // Redefine these in your program to override the defaults.
@@ -51,7 +57,7 @@ var diff_match_patch = function() {
 
   // The number of bits in an int.
   this.Match_MaxBits = 32;
-};
+}
 
 
 //  DIFF FUNCTIONS
@@ -66,18 +72,9 @@ var DIFF_DELETE = -1;
 var DIFF_INSERT = 1;
 var DIFF_EQUAL = 0;
 
-/**
- * Class representing one diff tuple.
- * ~Attempts to look like a two-element array (which is what this used to be).~
- * Constructor returns an actual two-element array, to allow destructing @JackuB
- * See https://github.com/JackuB/diff-match-patch/issues/14 for details
- * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
- * @param {string} text Text to be deleted, inserted, or retained.
- * @constructor
- */
-diff_match_patch.Diff = function(op, text) {
-  return [op, text];
-};
+/** @typedef {{0: number, 1: string}} */
+diff_match_patch.Diff;
+
 
 /**
  * Find the differences between two texts.  Simplifies the problem by stripping
@@ -87,7 +84,7 @@ diff_match_patch.Diff = function(op, text) {
  * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
  *     then don't run a line-level diff first to identify the changed areas.
  *     Defaults to true, which does a faster, slightly less optimal diff.
- * @param {number=} opt_deadline Optional time when the diff should be complete
+ * @param {number} opt_deadline Optional time when the diff should be complete
  *     by.  Used internally for recursive calls.  Users should set DiffTimeout
  *     instead.
  * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
@@ -110,13 +107,19 @@ diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
   }
 
   // Check for equality (speedup).
-  if (text1 == text2) {
+  if (text1.toString() == text2.toString()) {
     if (text1) {
-      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
+      return [[DIFF_EQUAL, text1]];
     }
     return [];
   }
 
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text1) || diff_match_patch.utf32_string.hasSupplemental(text2)) {
+    text1 = diff_match_patch.utf32_string.from(text1);
+    text2 = diff_match_patch.utf32_string.from(text2);
+  }
+
   if (typeof opt_checklines == 'undefined') {
     opt_checklines = true;
   }
@@ -138,11 +141,11 @@ diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
   var diffs = this.diff_compute_(text1, text2, checklines, deadline);
 
   // Restore the prefix and suffix.
-  if (commonprefix) {
-    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
+  if (commonprefix.length) {
+    diffs.unshift([DIFF_EQUAL, commonprefix]);
   }
-  if (commonsuffix) {
-    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
+  if (commonsuffix.length) {
+    diffs.push([DIFF_EQUAL, commonsuffix]);
   }
   this.diff_cleanupMerge(diffs);
   return diffs;
@@ -163,16 +166,17 @@ diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
  */
 diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
     deadline) {
+
   var diffs;
 
-  if (!text1) {
+  if (!text1.length) {
     // Just add some text (speedup).
-    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
+    return [[DIFF_INSERT, text2]];
   }
 
-  if (!text2) {
+  if (!text2.length) {
     // Just delete some text (speedup).
-    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
+    return [[DIFF_DELETE, text1]];
   }
 
   var longtext = text1.length > text2.length ? text1 : text2;
@@ -180,10 +184,9 @@ diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
   var i = longtext.indexOf(shorttext);
   if (i != -1) {
     // Shorter text is inside the longer text (speedup).
-    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
-             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
-             new diff_match_patch.Diff(DIFF_INSERT,
-                 longtext.substring(i + shorttext.length))];
+    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
+             [DIFF_EQUAL, shorttext],
+             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
     // Swap insertions for deletions if diff is reversed.
     if (text1.length > text2.length) {
       diffs[0][0] = diffs[2][0] = DIFF_DELETE;
@@ -194,8 +197,7 @@ diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
   if (shorttext.length == 1) {
     // Single character string.
     // After the previous speedup, the character can't be an equality.
-    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
-            new diff_match_patch.Diff(DIFF_INSERT, text2)];
+    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
   }
 
   // Check to see if the problem can be split in two.
@@ -211,8 +213,7 @@ diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
     var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
     var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
     // Merge the results.
-    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
-                          diffs_b);
+    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
   }
 
   if (checklines && text1.length > 100 && text2.length > 100) {
@@ -234,6 +235,7 @@ diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
  * @private
  */
 diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
+
   // Scan the text on a line-by-line basis first.
   var a = this.diff_linesToChars_(text1, text2);
   text1 = a.chars1;
@@ -249,7 +251,7 @@ diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
 
   // Rediff any replacement blocks, this time character-by-character.
   // Add a dummy entry at the end.
-  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
+  diffs.push([DIFF_EQUAL, '']);
   var pointer = 0;
   var count_delete = 0;
   var count_insert = 0;
@@ -259,11 +261,11 @@ diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
     switch (diffs[pointer][0]) {
       case DIFF_INSERT:
         count_insert++;
-        text_insert += diffs[pointer][1];
+        text_insert = text_insert.concat(diffs[pointer][1]);
         break;
       case DIFF_DELETE:
         count_delete++;
-        text_delete += diffs[pointer][1];
+        text_delete = text_delete.concat(diffs[pointer][1]);
         break;
       case DIFF_EQUAL:
         // Upon reaching an equality, check for prior redundancies.
@@ -272,12 +274,11 @@ diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
           diffs.splice(pointer - count_delete - count_insert,
                        count_delete + count_insert);
           pointer = pointer - count_delete - count_insert;
-          var subDiff =
-              this.diff_main(text_delete, text_insert, false, deadline);
-          for (var j = subDiff.length - 1; j >= 0; j--) {
-            diffs.splice(pointer, 0, subDiff[j]);
+          var a = this.diff_main(text_delete, text_insert, false, deadline);
+          for (var j = a.length - 1; j >= 0; j--) {
+            diffs.splice(pointer, 0, a[j]);
           }
-          pointer = pointer + subDiff.length;
+          pointer = pointer + a.length;
         }
         count_insert = 0;
         count_delete = 0;
@@ -304,6 +305,7 @@ diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  * @private
  */
 diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
+
   // Cache the text lengths to prevent multiple calls.
   var text1_length = text1.length;
   var text2_length = text2.length;
@@ -411,8 +413,7 @@ diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
   }
   // Diff took too long and hit the deadline or
   // number of diffs equals number of characters, no commonality at all.
-  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
-          new diff_match_patch.Diff(DIFF_INSERT, text2)];
+  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
 };
 
 
@@ -429,6 +430,7 @@ diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  */
 diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
     deadline) {
+
   var text1a = text1.substring(0, x);
   var text2a = text2.substring(0, y);
   var text1b = text1.substring(x);
@@ -454,12 +456,13 @@ diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
  * @private
  */
 diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
+
   var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
   var lineHash = {};   // e.g. lineHash['Hello\n'] == 4
 
   // '\x00' is a valid character, but various debuggers don't like it.
   // So we'll insert a junk entry to avoid generating a null character.
-  lineArray[0] = '';
+  lineArray[0] = text1.substring(0, 0);
 
   /**
    * Split a text into an array of strings.  Reduce the texts to a string of
@@ -484,10 +487,11 @@ diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
         lineEnd = text.length - 1;
       }
       var line = text.substring(lineStart, lineEnd + 1);
+      var lineKey = line.toString();
 
-      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
-          (lineHash[line] !== undefined)) {
-        chars += String.fromCharCode(lineHash[line]);
+      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(lineKey) :
+          (lineHash[lineKey] !== undefined)) {
+        chars += String.fromCharCode(lineHash[lineKey]);
       } else {
         if (lineArrayLength == maxLines) {
           // Bail out at 65535 because
@@ -496,7 +500,7 @@ diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
           lineEnd = text.length;
         }
         chars += String.fromCharCode(lineArrayLength);
-        lineHash[line] = lineArrayLength;
+        lineHash[lineKey] = lineArrayLength;
         lineArray[lineArrayLength++] = line;
       }
       lineStart = lineEnd + 1;
@@ -520,13 +524,20 @@ diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  * @private
  */
 diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
-  for (var i = 0; i < diffs.length; i++) {
-    var chars = diffs[i][1];
-    var text = [];
-    for (var j = 0; j < chars.length; j++) {
-      text[j] = lineArray[chars.charCodeAt(j)];
+
+  for (var x = 0; x < diffs.length; x++) {
+    var chars = diffs[x][1];
+    var text;
+    if (chars.length === 0) {
+      // don't lose string type (regular or utf32_string)
+      text = lineArray[0].substring(0, 0);
+    } else {
+      text = lineArray[chars.charCodeAt(0)]
     }
-    diffs[i][1] = text.join('');
+    for (var y = 1; y < chars.length; y++) {
+      text = text.concat(lineArray[chars.charCodeAt(y)]);
+    }
+    diffs[x][1] = text;
   }
 };
 
@@ -543,15 +554,22 @@ diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
   if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
     return 0;
   }
+
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text1) || diff_match_patch.utf32_string.hasSupplemental(text2)) {
+    text1 = diff_match_patch.utf32_string.from(text1);
+    text2 = diff_match_patch.utf32_string.from(text2);
+  }
+
   // Binary search.
-  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
+  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
   var pointermin = 0;
   var pointermax = Math.min(text1.length, text2.length);
   var pointermid = pointermax;
   var pointerstart = 0;
   while (pointermin < pointermid) {
-    if (text1.substring(pointerstart, pointermid) ==
-        text2.substring(pointerstart, pointermid)) {
+    if (text1.substring(pointerstart, pointermid).toString() ==
+        text2.substring(pointerstart, pointermid).toString()) {
       pointermin = pointermid;
       pointerstart = pointermin;
     } else {
@@ -575,15 +593,21 @@ diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
       text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
     return 0;
   }
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text1) || diff_match_patch.utf32_string.hasSupplemental(text2)) {
+    text1 = diff_match_patch.utf32_string.from(text1);
+    text2 = diff_match_patch.utf32_string.from(text2);
+  }
+
   // Binary search.
-  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
+  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
   var pointermin = 0;
   var pointermax = Math.min(text1.length, text2.length);
   var pointermid = pointermax;
   var pointerend = 0;
   while (pointermin < pointermid) {
-    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
-        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
+    if (text1.substring(text1.length - pointermid, text1.length - pointerend).toString() ==
+        text2.substring(text2.length - pointermid, text2.length - pointerend).toString()) {
       pointermin = pointermid;
       pointerend = pointermin;
     } else {
@@ -604,6 +628,7 @@ diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  * @private
  */
 diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
+
   // Cache the text lengths to prevent multiple calls.
   var text1_length = text1.length;
   var text2_length = text2.length;
@@ -619,13 +644,13 @@ diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
   }
   var text_length = Math.min(text1_length, text2_length);
   // Quick check for the worst case.
-  if (text1 == text2) {
+  if (text1.toString() == text2.toString()) {
     return text_length;
   }
 
   // Start by looking for a single character match
   // and increase length until no match is found.
-  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
+  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
   var best = 0;
   var length = 1;
   while (true) {
@@ -635,8 +660,8 @@ diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
       return best;
     }
     length += found;
-    if (found == 0 || text1.substring(text_length - length) ==
-        text2.substring(0, length)) {
+    if (found == 0 || text1.substring(text_length - length).toString() ==
+        text2.substring(0, length).toString()) {
       best = length;
       length++;
     }
@@ -656,6 +681,7 @@ diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  * @private
  */
 diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
+
   if (this.Diff_Timeout <= 0) {
     // Don't risk returning a non-optimal diff if we have unlimited time.
     return null;
@@ -683,7 +709,7 @@ diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
     // Start with a 1/4 length substring at position i as a seed.
     var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
     var j = -1;
-    var best_common = '';
+    var best_common = longtext.substring(0, 0);  // retain string type
     var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
     while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
       var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
@@ -691,8 +717,8 @@ diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
       var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                                shorttext.substring(0, j));
       if (best_common.length < suffixLength + prefixLength) {
-        best_common = shorttext.substring(j - suffixLength, j) +
-            shorttext.substring(j, j + prefixLength);
+        best_common = shorttext.substring(j - suffixLength, j).concat(
+            shorttext.substring(j, j + prefixLength));
         best_longtext_a = longtext.substring(0, i - suffixLength);
         best_longtext_b = longtext.substring(i + prefixLength);
         best_shorttext_a = shorttext.substring(0, j - suffixLength);
@@ -748,11 +774,12 @@ diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
  */
 diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
+
   var changes = false;
   var equalities = [];  // Stack of indices where equalities are found.
   var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
   /** @type {?string} */
-  var lastEquality = null;
+  var lastequality = null;
   // Always equal to diffs[equalities[equalitiesLength - 1]][1]
   var pointer = 0;  // Index of current position.
   // Number of characters that changed prior to the equality.
@@ -768,7 +795,7 @@ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
       length_deletions1 = length_deletions2;
       length_insertions2 = 0;
       length_deletions2 = 0;
-      lastEquality = diffs[pointer][1];
+      lastequality = diffs[pointer][1];
     } else {  // An insertion or deletion.
       if (diffs[pointer][0] == DIFF_INSERT) {
         length_insertions2 += diffs[pointer][1].length;
@@ -777,13 +804,13 @@ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
       }
       // Eliminate an equality that is smaller or equal to the edits on both
       // sides of it.
-      if (lastEquality && (lastEquality.length <=
+      if (lastequality && (lastequality.length <=
           Math.max(length_insertions1, length_deletions1)) &&
-          (lastEquality.length <= Math.max(length_insertions2,
+          (lastequality.length <= Math.max(length_insertions2,
                                            length_deletions2))) {
         // Duplicate record.
         diffs.splice(equalities[equalitiesLength - 1], 0,
-                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
+                     [DIFF_DELETE, lastequality]);
         // Change second copy to insert.
         diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
         // Throw away the equality we just deleted.
@@ -795,7 +822,7 @@ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
         length_deletions1 = 0;
         length_insertions2 = 0;
         length_deletions2 = 0;
-        lastEquality = null;
+        lastequality = null;
         changes = true;
       }
     }
@@ -826,8 +853,8 @@ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
         if (overlap_length1 >= deletion.length / 2 ||
             overlap_length1 >= insertion.length / 2) {
           // Overlap found.  Insert an equality and trim the surrounding edits.
-          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
-              insertion.substring(0, overlap_length1)));
+          diffs.splice(pointer, 0,
+              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
           diffs[pointer - 1][1] =
               deletion.substring(0, deletion.length - overlap_length1);
           diffs[pointer + 1][1] = insertion.substring(overlap_length1);
@@ -838,8 +865,8 @@ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
             overlap_length2 >= insertion.length / 2) {
           // Reverse overlap found.
           // Insert an equality and swap and trim the surrounding edits.
-          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
-              deletion.substring(0, overlap_length2)));
+          diffs.splice(pointer, 0,
+              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
           diffs[pointer - 1][0] = DIFF_INSERT;
           diffs[pointer - 1][1] =
               insertion.substring(0, insertion.length - overlap_length2);
@@ -863,6 +890,7 @@ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
  */
 diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
+
   /**
    * Given two strings, compute a score representing whether the internal
    * boundary falls on logical boundaries.
@@ -874,7 +902,7 @@ diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
    * @private
    */
   function diff_cleanupSemanticScore_(one, two) {
-    if (!one || !two) {
+    if (!one.length || !two.length) {
       // Edges are the best.
       return 6;
     }
@@ -935,8 +963,8 @@ diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
       if (commonOffset) {
         var commonString = edit.substring(edit.length - commonOffset);
         equality1 = equality1.substring(0, equality1.length - commonOffset);
-        edit = commonString + edit.substring(0, edit.length - commonOffset);
-        equality2 = commonString + equality2;
+        edit = commonString.concat(edit.substring(0, edit.length - commonOffset));
+        equality2 = commonString.concat(equality2);
       }
 
       // Second, step character by character right, looking for the best fit.
@@ -946,8 +974,8 @@ diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
       var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
           diff_cleanupSemanticScore_(edit, equality2);
       while (edit.charAt(0) === equality2.charAt(0)) {
-        equality1 += edit.charAt(0);
-        edit = edit.substring(1) + equality2.charAt(0);
+        equality1 = equality1.concat(edit.charAt(0));
+        edit = edit.substring(1).concat(equality2.charAt(0));
         equality2 = equality2.substring(1);
         var score = diff_cleanupSemanticScore_(equality1, edit) +
             diff_cleanupSemanticScore_(edit, equality2);
@@ -960,16 +988,16 @@ diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
         }
       }
 
-      if (diffs[pointer - 1][1] != bestEquality1) {
+      if (diffs[pointer - 1][1].toString() != bestEquality1.toString()) {
         // We have an improvement, save it back to the diff.
-        if (bestEquality1) {
+        if (bestEquality1.length) {
           diffs[pointer - 1][1] = bestEquality1;
         } else {
           diffs.splice(pointer - 1, 1);
           pointer--;
         }
         diffs[pointer][1] = bestEdit;
-        if (bestEquality2) {
+        if (bestEquality2.length) {
           diffs[pointer + 1][1] = bestEquality2;
         } else {
           diffs.splice(pointer + 1, 1);
@@ -993,11 +1021,12 @@ diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
  * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
  */
 diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
+
   var changes = false;
   var equalities = [];  // Stack of indices where equalities are found.
   var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
   /** @type {?string} */
-  var lastEquality = null;
+  var lastequality = null;
   // Always equal to diffs[equalities[equalitiesLength - 1]][1]
   var pointer = 0;  // Index of current position.
   // Is there an insertion operation before the last equality.
@@ -1016,11 +1045,11 @@ diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
         equalities[equalitiesLength++] = pointer;
         pre_ins = post_ins;
         pre_del = post_del;
-        lastEquality = diffs[pointer][1];
+        lastequality = diffs[pointer][1];
       } else {
         // Not a candidate, and can never become one.
         equalitiesLength = 0;
-        lastEquality = null;
+        lastequality = null;
       }
       post_ins = post_del = false;
     } else {  // An insertion or deletion.
@@ -1037,16 +1066,16 @@ diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
        * <ins>A</del>X<ins>C</ins><del>D</del>
        * <ins>A</ins><del>B</del>X<del>C</del>
        */
-      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||
-                           ((lastEquality.length < this.Diff_EditCost / 2) &&
+      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
+                           ((lastequality.length < this.Diff_EditCost / 2) &&
                             (pre_ins + pre_del + post_ins + post_del) == 3))) {
         // Duplicate record.
         diffs.splice(equalities[equalitiesLength - 1], 0,
-                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
+                     [DIFF_DELETE, lastequality]);
         // Change second copy to insert.
         diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
         equalitiesLength--;  // Throw away the equality we just deleted;
-        lastEquality = null;
+        lastequality = null;
         if (pre_ins && pre_del) {
           // No changes made which could affect previous entry, keep going.
           post_ins = post_del = true;
@@ -1075,24 +1104,26 @@ diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
  */
 diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
-  // Add a dummy entry at the end.
-  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
+  // Preserve string type:
+  var emptyString = (diffs.length === 0 ? '' : diffs[0][1].substring(0, 0));
+
+  diffs.push([DIFF_EQUAL, emptyString]);  // Add a dummy entry at the end.
   var pointer = 0;
   var count_delete = 0;
   var count_insert = 0;
-  var text_delete = '';
-  var text_insert = '';
+  var text_delete = emptyString;
+  var text_insert = emptyString;
   var commonlength;
   while (pointer < diffs.length) {
     switch (diffs[pointer][0]) {
       case DIFF_INSERT:
         count_insert++;
-        text_insert += diffs[pointer][1];
+        text_insert = text_insert.concat(diffs[pointer][1]);
         pointer++;
         break;
       case DIFF_DELETE:
         count_delete++;
-        text_delete += diffs[pointer][1];
+        text_delete = text_delete.concat(diffs[pointer][1]);
         pointer++;
         break;
       case DIFF_EQUAL:
@@ -1105,11 +1136,12 @@ diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
               if ((pointer - count_delete - count_insert) > 0 &&
                   diffs[pointer - count_delete - count_insert - 1][0] ==
                   DIFF_EQUAL) {
-                diffs[pointer - count_delete - count_insert - 1][1] +=
-                    text_insert.substring(0, commonlength);
+                diffs[pointer - count_delete - count_insert - 1][1] =
+                  diffs[pointer - count_delete - count_insert - 1][1].concat(
+                    text_insert.substring(0, commonlength));
               } else {
-                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
-                    text_insert.substring(0, commonlength)));
+                diffs.splice(0, 0, [DIFF_EQUAL,
+                                    text_insert.substring(0, commonlength)]);
                 pointer++;
               }
               text_insert = text_insert.substring(commonlength);
@@ -1119,7 +1151,7 @@ diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
             commonlength = this.diff_commonSuffix(text_insert, text_delete);
             if (commonlength !== 0) {
               diffs[pointer][1] = text_insert.substring(text_insert.length -
-                  commonlength) + diffs[pointer][1];
+                  commonlength).concat(diffs[pointer][1]);
               text_insert = text_insert.substring(0, text_insert.length -
                   commonlength);
               text_delete = text_delete.substring(0, text_delete.length -
@@ -1127,34 +1159,34 @@ diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
             }
           }
           // Delete the offending records and add the merged ones.
-          pointer -= count_delete + count_insert;
-          diffs.splice(pointer, count_delete + count_insert);
-          if (text_delete.length) {
-            diffs.splice(pointer, 0,
-                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
-            pointer++;
-          }
-          if (text_insert.length) {
-            diffs.splice(pointer, 0,
-                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
-            pointer++;
+          if (count_delete === 0) {
+            diffs.splice(pointer - count_insert,
+                count_delete + count_insert, [DIFF_INSERT, text_insert]);
+          } else if (count_insert === 0) {
+            diffs.splice(pointer - count_delete,
+                count_delete + count_insert, [DIFF_DELETE, text_delete]);
+          } else {
+            diffs.splice(pointer - count_delete - count_insert,
+                count_delete + count_insert, [DIFF_DELETE, text_delete],
+                [DIFF_INSERT, text_insert]);
           }
-          pointer++;
+          pointer = pointer - count_delete - count_insert +
+                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
         } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
           // Merge this equality with the previous one.
-          diffs[pointer - 1][1] += diffs[pointer][1];
+          diffs[pointer - 1][1] = diffs[pointer - 1][1].concat(diffs[pointer][1]);
           diffs.splice(pointer, 1);
         } else {
           pointer++;
         }
         count_insert = 0;
         count_delete = 0;
-        text_delete = '';
-        text_insert = '';
+        text_delete = emptyString;
+        text_insert = emptyString;
         break;
     }
   }
-  if (diffs[diffs.length - 1][1] === '') {
+  if (diffs[diffs.length - 1][1].length === 0) {
     diffs.pop();  // Remove the dummy entry at the end.
   }
 
@@ -1169,21 +1201,20 @@ diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
         diffs[pointer + 1][0] == DIFF_EQUAL) {
       // This is a single edit surrounded by equalities.
       if (diffs[pointer][1].substring(diffs[pointer][1].length -
-          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
+          diffs[pointer - 1][1].length).toString() == diffs[pointer - 1][1].toString()) {
         // Shift the edit over the previous equality.
-        diffs[pointer][1] = diffs[pointer - 1][1] +
+        diffs[pointer][1] = diffs[pointer - 1][1].concat(
             diffs[pointer][1].substring(0, diffs[pointer][1].length -
-                                        diffs[pointer - 1][1].length);
-        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
+                                        diffs[pointer - 1][1].length));
+        diffs[pointer + 1][1] = diffs[pointer - 1][1].concat(diffs[pointer + 1][1]);
         diffs.splice(pointer - 1, 1);
         changes = true;
-      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
-          diffs[pointer + 1][1]) {
+      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length).toString() ==
+          diffs[pointer + 1][1].toString()) {
         // Shift the edit over the next equality.
-        diffs[pointer - 1][1] += diffs[pointer + 1][1];
+        diffs[pointer - 1][1] = diffs[pointer - 1][1].concat(diffs[pointer + 1][1]);
         diffs[pointer][1] =
-            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
-            diffs[pointer + 1][1];
+            diffs[pointer][1].substring(diffs[pointer + 1][1].length).concat(            diffs[pointer + 1][1]);
         diffs.splice(pointer + 1, 1);
         changes = true;
       }
@@ -1206,6 +1237,7 @@ diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  * @return {number} Location within text2.
  */
 diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
+
   var chars1 = 0;
   var chars2 = 0;
   var last_chars1 = 0;
@@ -1239,6 +1271,7 @@ diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  * @return {string} HTML representation.
  */
 diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
+
   var html = [];
   var pattern_amp = /&/g;
   var pattern_lt = /</g;
@@ -1251,13 +1284,13 @@ diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
         .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
     switch (op) {
       case DIFF_INSERT:
-        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
+        html[x] = '<ins style="background:#e6ffe6;">' + text.toString() + '</ins>';
         break;
       case DIFF_DELETE:
-        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
+        html[x] = '<del style="background:#ffe6e6;">' + text.toString() + '</del>';
         break;
       case DIFF_EQUAL:
-        html[x] = '<span>' + text + '</span>';
+        html[x] = '<span>' + text.toString() + '</span>';
         break;
     }
   }
@@ -1271,13 +1304,27 @@ diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  * @return {string} Source text.
  */
 diff_match_patch.prototype.diff_text1 = function(diffs) {
+  return this.diff_text1_(diffs).toString();
+};
+
+
+/**
+ * Same as diff_text1 but might return a utf32_string.
+ * @private
+ */
+diff_match_patch.prototype.diff_text1_ = function(diffs) {
   var text = [];
   for (var x = 0; x < diffs.length; x++) {
     if (diffs[x][0] !== DIFF_INSERT) {
-      text[x] = diffs[x][1];
+      text[x] = diffs[x][1].toString();
     }
   }
-  return text.join('');
+  var retval = text.join('');
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(retval)) {
+    retval = diff_match_patch.utf32_string.from(retval);
+  }
+  return retval;
 };
 
 
@@ -1287,13 +1334,27 @@ diff_match_patch.prototype.diff_text1 = function(diffs) {
  * @return {string} Destination text.
  */
 diff_match_patch.prototype.diff_text2 = function(diffs) {
+  return this.diff_text2_(diffs).toString();
+};
+
+
+/**
+ * Same as diff_text2 but might return a utf32_string.
+ * @private
+ */
+diff_match_patch.prototype.diff_text2_ = function(diffs) {
   var text = [];
   for (var x = 0; x < diffs.length; x++) {
     if (diffs[x][0] !== DIFF_DELETE) {
-      text[x] = diffs[x][1];
+      text[x] = diffs[x][1].toString();
     }
   }
-  return text.join('');
+  var retval = text.join('');
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(retval)) {
+    retval = diff_match_patch.utf32_string.from(retval);
+  }
+  return retval;
 };
 
 
@@ -1366,6 +1427,11 @@ diff_match_patch.prototype.diff_toDelta = function(diffs) {
  * @throws {!Error} If invalid input.
  */
 diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text1)) {
+    text1 = diff_match_patch.utf32_string.from(text1);
+  }
+
   var diffs = [];
   var diffsLength = 0;  // Keeping our own length var is faster in JS.
   var pointer = 0;  // Cursor in text1
@@ -1377,8 +1443,7 @@ diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
     switch (tokens[x].charAt(0)) {
       case '+':
         try {
-          diffs[diffsLength++] =
-              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
+          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
         } catch (ex) {
           // Malformed URI sequence.
           throw new Error('Illegal escape in diff_fromDelta: ' + param);
@@ -1393,9 +1458,9 @@ diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
         }
         var text = text1.substring(pointer, pointer += n);
         if (tokens[x].charAt(0) == '=') {
-          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
+          diffs[diffsLength++] = [DIFF_EQUAL, text];
         } else {
-          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
+          diffs[diffsLength++] = [DIFF_DELETE, text];
         }
         break;
       default:
@@ -1430,15 +1495,19 @@ diff_match_patch.prototype.match_main = function(text, pattern, loc) {
   if (text == null || pattern == null || loc == null) {
     throw new Error('Null input. (match_main)');
   }
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text)) {
+    text = diff_match_patch.utf32_string.from(text);
+  }
 
   loc = Math.max(0, Math.min(loc, text.length));
-  if (text == pattern) {
+  if (text.toString() == pattern.toString()) {
     // Shortcut (potentially not guaranteed by the algorithm)
     return 0;
   } else if (!text.length) {
     // Nothing to match.
     return -1;
-  } else if (text.substring(loc, loc + pattern.length) == pattern) {
+  } else if (text.substring(loc, loc + pattern.length).toString() == pattern.toString()) {
     // Perfect match at the perfect spot!  (Includes case of null pattern)
     return loc;
   } else {
@@ -1598,9 +1667,6 @@ diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
   if (text.length == 0) {
     return;
   }
-  if (patch.start2 === null) {
-    throw Error('patch not initialized');
-  }
   var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
   var padding = 0;
 
@@ -1618,14 +1684,14 @@ diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
 
   // Add the prefix.
   var prefix = text.substring(patch.start2 - padding, patch.start2);
-  if (prefix) {
-    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
+  if (prefix.length) {
+    patch.diffs.unshift([DIFF_EQUAL, prefix]);
   }
   // Add the suffix.
   var suffix = text.substring(patch.start2 + patch.length1,
                               patch.start2 + patch.length1 + padding);
-  if (suffix) {
-    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
+  if (suffix.length) {
+    patch.diffs.push([DIFF_EQUAL, suffix]);
   }
 
   // Roll back the start points.
@@ -1653,9 +1719,9 @@ diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  *
  * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
  * Array of diff tuples for text1 to text2 (method 2).
- * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
+ * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
  * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
- * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
+ * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
  * for text1 to text2 (method 4) or undefined (methods 1,2,3).
  * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
  */
@@ -1676,7 +1742,7 @@ diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
     // Method 2: diffs
     // Compute text1 from diffs.
     diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
-    text1 = this.diff_text1(diffs);
+    text1 = this.diff_text1_(diffs);
   } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
       typeof opt_c == 'undefined') {
     // Method 3: text1, diffs
@@ -1692,6 +1758,10 @@ diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
     throw new Error('Unknown call format to patch_make.');
   }
 
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text1)) {
+    text1 = diff_match_patch.utf32_string.from(text1);
+  }
   if (diffs.length === 0) {
     return [];  // Get rid of the null case.
   }
@@ -1719,15 +1789,15 @@ diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
       case DIFF_INSERT:
         patch.diffs[patchDiffLength++] = diffs[x];
         patch.length2 += diff_text.length;
-        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
-                         postpatch_text.substring(char_count2);
+        postpatch_text = postpatch_text.substring(0, char_count2).concat(
+                         diff_text, postpatch_text.substring(char_count2));
         break;
       case DIFF_DELETE:
         patch.length1 += diff_text.length;
         patch.diffs[patchDiffLength++] = diffs[x];
-        postpatch_text = postpatch_text.substring(0, char_count2) +
-                         postpatch_text.substring(char_count2 +
-                             diff_text.length);
+        postpatch_text = postpatch_text.substring(0, char_count2).concat(
+                         postpatch_text.substring(
+                          char_count2 + diff_text.length));
         break;
       case DIFF_EQUAL:
         if (diff_text.length <= 2 * this.Patch_Margin &&
@@ -1744,7 +1814,7 @@ diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
             patch = new diff_match_patch.patch_obj();
             patchDiffLength = 0;
             // Unlike Unidiff, our patch lists have a rolling context.
-            // https://github.com/google/diff-match-patch/wiki/Unidiff
+            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
             // Update prepatch text & pos to reflect the application of the
             // just completed patch.
             prepatch_text = postpatch_text;
@@ -1785,8 +1855,7 @@ diff_match_patch.prototype.patch_deepCopy = function(patches) {
     var patchCopy = new diff_match_patch.patch_obj();
     patchCopy.diffs = [];
     for (var y = 0; y < patch.diffs.length; y++) {
-      patchCopy.diffs[y] =
-          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
+      patchCopy.diffs[y] = patch.diffs[y].slice();
     }
     patchCopy.start1 = patch.start1;
     patchCopy.start2 = patch.start2;
@@ -1811,11 +1880,16 @@ diff_match_patch.prototype.patch_apply = function(patches, text) {
     return [text, []];
   }
 
+  // Check for Unicode
+  if (diff_match_patch.utf32_string.hasSupplemental(text)) {
+    text = diff_match_patch.utf32_string.from(text);
+  }
+
   // Deep copy the patches so that no changes are made to originals.
   patches = this.patch_deepCopy(patches);
 
   var nullPadding = this.patch_addPadding(patches);
-  text = nullPadding + text + nullPadding;
+  text = nullPadding.concat(text, nullPadding);
 
   this.patch_splitMax(patches);
   // delta keeps track of the offset between the expected and actual location
@@ -1826,7 +1900,7 @@ diff_match_patch.prototype.patch_apply = function(patches, text) {
   var results = [];
   for (var x = 0; x < patches.length; x++) {
     var expected_loc = patches[x].start2 + delta;
-    var text1 = this.diff_text1(patches[x].diffs);
+    var text1 = this.diff_text1_(patches[x].diffs);
     var start_loc;
     var end_loc = -1;
     if (text1.length > this.Match_MaxBits) {
@@ -1861,11 +1935,11 @@ diff_match_patch.prototype.patch_apply = function(patches, text) {
       } else {
         text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
       }
-      if (text1 == text2) {
+      if (text1.toString() == text2.toString()) {
         // Perfect match, just shove the replacement text in.
-        text = text.substring(0, start_loc) +
-               this.diff_text2(patches[x].diffs) +
-               text.substring(start_loc + text1.length);
+        text = text.substring(0, start_loc).concat(
+               this.diff_text2_(patches[x].diffs),
+               text.substring(start_loc + text1.length));
       } else {
         // Imperfect match.  Run a diff to get a framework of equivalent
         // indices.
@@ -1885,12 +1959,11 @@ diff_match_patch.prototype.patch_apply = function(patches, text) {
               index2 = this.diff_xIndex(diffs, index1);
             }
             if (mod[0] === DIFF_INSERT) {  // Insertion
-              text = text.substring(0, start_loc + index2) + mod[1] +
-                     text.substring(start_loc + index2);
+              text = text.substring(0, start_loc + index2).concat(
+                     mod[1], text.substring(start_loc + index2));
             } else if (mod[0] === DIFF_DELETE) {  // Deletion
-              text = text.substring(0, start_loc + index2) +
-                     text.substring(start_loc + this.diff_xIndex(diffs,
-                         index1 + mod[1].length));
+              text = text.substring(0, start_loc + index2).concat(
+                     text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length)));
             }
             if (mod[0] !== DIFF_DELETE) {
               index1 += mod[1].length;
@@ -1918,6 +1991,9 @@ diff_match_patch.prototype.patch_addPadding = function(patches) {
   for (var x = 1; x <= paddingLength; x++) {
     nullPadding += String.fromCharCode(x);
   }
+  if (patches[0].diffs[0][1].codePoints) {
+    nullPadding = diff_match_patch.utf32_string.from(nullPadding);
+  }
 
   // Bump all the patches forward.
   for (var x = 0; x < patches.length; x++) {
@@ -1930,7 +2006,7 @@ diff_match_patch.prototype.patch_addPadding = function(patches) {
   var diffs = patch.diffs;
   if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
     // Add nullPadding equality.
-    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
+    diffs.unshift([DIFF_EQUAL, nullPadding]);
     patch.start1 -= paddingLength;  // Should be 0.
     patch.start2 -= paddingLength;  // Should be 0.
     patch.length1 += paddingLength;
@@ -1938,7 +2014,7 @@ diff_match_patch.prototype.patch_addPadding = function(patches) {
   } else if (paddingLength > diffs[0][1].length) {
     // Grow first equality.
     var extraLength = paddingLength - diffs[0][1].length;
-    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
+    diffs[0][1] = nullPadding.substring(diffs[0][1].length).concat(diffs[0][1]);
     patch.start1 -= extraLength;
     patch.start2 -= extraLength;
     patch.length1 += extraLength;
@@ -1950,13 +2026,13 @@ diff_match_patch.prototype.patch_addPadding = function(patches) {
   diffs = patch.diffs;
   if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
     // Add nullPadding equality.
-    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
+    diffs.push([DIFF_EQUAL, nullPadding]);
     patch.length1 += paddingLength;
     patch.length2 += paddingLength;
   } else if (paddingLength > diffs[diffs.length - 1][1].length) {
     // Grow last equality.
     var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
-    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
+    diffs[diffs.length - 1][1] = diffs[diffs.length - 1][1].concat(nullPadding.substring(0, extraLength));
     patch.length1 += extraLength;
     patch.length2 += extraLength;
   }
@@ -1989,9 +2065,9 @@ diff_match_patch.prototype.patch_splitMax = function(patches) {
       var empty = true;
       patch.start1 = start1 - precontext.length;
       patch.start2 = start2 - precontext.length;
-      if (precontext !== '') {
+      if (precontext.toString() !== '') {
         patch.length1 = patch.length2 = precontext.length;
-        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
+        patch.diffs.push([DIFF_EQUAL, precontext]);
       }
       while (bigpatch.diffs.length !== 0 &&
              patch.length1 < patch_size - this.Patch_Margin) {
@@ -2010,7 +2086,7 @@ diff_match_patch.prototype.patch_splitMax = function(patches) {
           patch.length1 += diff_text.length;
           start1 += diff_text.length;
           empty = false;
-          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
+          patch.diffs.push([diff_type, diff_text]);
           bigpatch.diffs.shift();
         } else {
           // Deletion or equality.  Only take as much as we can stomach.
@@ -2024,8 +2100,8 @@ diff_match_patch.prototype.patch_splitMax = function(patches) {
           } else {
             empty = false;
           }
-          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
-          if (diff_text == bigpatch.diffs[0][1]) {
+          patch.diffs.push([diff_type, diff_text]);
+          if (diff_text.toString() == bigpatch.diffs[0][1].toString()) {
             bigpatch.diffs.shift();
           } else {
             bigpatch.diffs[0][1] =
@@ -2034,20 +2110,20 @@ diff_match_patch.prototype.patch_splitMax = function(patches) {
         }
       }
       // Compute the head context for the next patch.
-      precontext = this.diff_text2(patch.diffs);
+      precontext = this.diff_text2_(patch.diffs);
       precontext =
           precontext.substring(precontext.length - this.Patch_Margin);
       // Append the end context for this patch.
-      var postcontext = this.diff_text1(bigpatch.diffs)
+      var postcontext = this.diff_text1_(bigpatch.diffs)
                             .substring(0, this.Patch_Margin);
-      if (postcontext !== '') {
+      if (postcontext.toString() !== '') {
         patch.length1 += postcontext.length;
         patch.length2 += postcontext.length;
         if (patch.diffs.length !== 0 &&
             patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
-          patch.diffs[patch.diffs.length - 1][1] += postcontext;
+          patch.diffs[patch.diffs.length - 1][1] = patch.diffs[patch.diffs.length - 1][1].concat(postcontext);
         } else {
-          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
+          patch.diffs.push([DIFF_EQUAL, postcontext]);
         }
       }
       if (!empty) {
@@ -2126,13 +2202,13 @@ diff_match_patch.prototype.patch_fromText = function(textline) {
       }
       if (sign == '-') {
         // Deletion.
-        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
+        patch.diffs.push([DIFF_DELETE, line]);
       } else if (sign == '+') {
         // Insertion.
-        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
+        patch.diffs.push([DIFF_INSERT, line]);
       } else if (sign == ' ') {
         // Minor equality.
-        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
+        patch.diffs.push([DIFF_EQUAL, line]);
       } else if (sign == '@') {
         // Start of next patch.
         break;
@@ -2168,9 +2244,9 @@ diff_match_patch.patch_obj = function() {
 
 
 /**
- * Emulate GNU diff's format.
+ * Emmulate GNU diff's format.
  * Header: @@ -382,8 +481,9 @@
- * Indices are printed as 1-based, not 0-based.
+ * Indicies are printed as 1-based, not 0-based.
  * @return {string} The GNU diff string.
  */
 diff_match_patch.patch_obj.prototype.toString = function() {
@@ -2210,6 +2286,152 @@ diff_match_patch.patch_obj.prototype.toString = function() {
 };
 
 
+/** Whether to force the implementation to always use utf32_string. */
+diff_match_patch.force_utf32_string = false;
+
+
+/** A String-like class that treats each code point as a single character. */
+diff_match_patch.utf32_string = function() {
+  this.string = "";
+  this.codePoints = [];
+  this.length = 0;
+};
+
+
+diff_match_patch.utf32_string.hasSupplemental = function(text) {
+  // Require at least String.prototype.codePointAt(), ES5+
+  if (!String.prototype.codePointAt) {
+    return false;
+  }
+  if (text.codePoints) {
+    // Argument is another utf32_string; do not re-convert
+    return false;
+  }
+  if (diff_match_patch.force_utf32_string) {
+    // Override: force utf32_string conversion
+    return true;
+  }
+  for (var i=0; i<text.length; i++) {
+    var ch = text.charCodeAt(i);
+    if (ch >= 0xD800 && ch <= 0xDFFF) {
+      return true;
+    }
+  }
+  return false;
+};
+
+
+diff_match_patch.utf32_string.from = function(text) {
+  var result = new diff_match_patch.utf32_string();
+  for (var i=0; i<text.length; i++) {
+    var cp = text.codePointAt(i);
+    result.codePoints.push(cp);
+    if (cp > 0xFFFF) {
+      i++;
+    }
+  }
+  result.string = text;
+  result.length = result.codePoints.length;
+  return result;
+};
+
+
+diff_match_patch.utf32_string.prototype.charAt = function(i) {
+  if (i < 0 || i >= this.length) {
+    return "";
+  }
+  return String.fromCodePoint(this.codePoints[i]);
+};
+
+
+diff_match_patch.utf32_string.prototype.charCodeAt = function(i) {
+  if (i < 0 || i >= this.length) {
+    return 0;
+  }
+  return this.codePoints[i];
+};
+
+
+diff_match_patch.utf32_string.prototype.substring = function(start, end) {
+  var result = new diff_match_patch.utf32_string();
+  // Implemented according to String.substring specification:
+  // https://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.15
+  var len = this.length;
+  // TODO: Check for integers like the spec says?
+  var intStart = start;
+  var intEnd = (typeof end === 'undefined') ? len : end;
+  var finalStart = Math.min(Math.max(intStart, 0), len);
+  var finalEnd = Math.min(Math.max(intEnd, 0), len);
+  var from = Math.min(finalStart, finalEnd);
+  var to = Math.max(finalStart, finalEnd);
+
+  // Compute the indices for the actual substring; we must maintain the string
+  // because toString() operations are expected to be fast.
+  var stringFrom = 0;
+  for (var i=0; i<from; i++) {
+    stringFrom += this.codePoints[i] <= 0xFFFF ? 1 : 2;
+  }
+  var stringTo = stringFrom;
+  for (var i=from; i<to; i++) {
+    stringTo += this.codePoints[i] <= 0xFFFF ? 1 : 2;
+  }
+  result.string = this.string.substring(stringFrom, stringTo);
+  result.codePoints = this.codePoints.slice(from, to);
+  result.length = result.codePoints.length;
+  return result;
+};
+
+
+diff_match_patch.utf32_string.prototype.indexOf = function(other, start) {
+  return this.string.indexOf(other.toString(), start);
+};
+
+
+diff_match_patch.utf32_string.prototype.lastIndexOf = function(other, start) {
+  return this.string.lastIndexOf(other.toString(), start);
+};
+
+
+diff_match_patch.utf32_string.prototype.concat = function() {
+  if (arguments.length > 1) {
+    var first = this.concat(arguments[0]);
+    return first.concat.apply(first, Array.prototype.slice.call(arguments, 1));
+  }
+
+  // Make sure input is a utf32_string
+  var other = arguments[0];
+  if (!other.codePoints) {
+    other = diff_match_patch.utf32_string.from(other);
+  }
+
+  var result = new diff_match_patch.utf32_string();
+  result.string = this.string + other.string;
+  result.codePoints = [].concat(this.codePoints, other.codePoints);
+  result.length = result.codePoints.length;
+  return result;
+};
+
+
+diff_match_patch.utf32_string.prototype.match = function() {
+  return this.string.match.apply(this.string, arguments);
+};
+
+
+diff_match_patch.utf32_string.prototype.replace = function() {
+  return diff_match_patch.utf32_string.from(this.string.replace.apply(this.string, arguments));
+};
+
+
+diff_match_patch.utf32_string.prototype.valueOf = function() {
+  throw new Error("warning: implicit conversion attempted on utf32_string; use toString instead");
+  return this.string;
+};
+
+
+diff_match_patch.utf32_string.prototype.toString = function() {
+  return this.string;
+};
+
 // The following export code was added by @ForbesLindesay
 module.exports = diff_match_patch;
 module.exports['diff_match_patch'] = diff_match_patch;
